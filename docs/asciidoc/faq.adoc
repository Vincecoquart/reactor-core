[[faq]]
= FAQ, Best Practices, and "How do I...?"

[[faq.wrap-blocking]]
== How Do I Wrap a Synchronous, Blocking Call?

It's often the case that a source of information is synchronous and blocking.
To deal with such sources in your Reactor applications, apply the following
pattern:

====
[source,java]
----
Mono blockingWrapper = Mono.fromCallable(() -> { <1>
    return /* make a remote synchronous call */ <2>
});
blockingWrapper = blockingWrapper.subscribeOn(Schedulers.elastic()); <3>
----
<1> Create a new `Mono` by using `fromCallable`.
<2> Return the asynchronous, blocking resource.
<3> Ensure each subscription will happen on a dedicated single-threaded worker
from `Schedulers.elastic()`.
====

You should use a Mono because the source returns one value. You should use
`Schedulers.elastic` because it creates a dedicated thread to wait for the
blocking resource without tying up some other resource.

Note that `subscribeOn` does not subscribe to the `Mono`. It specifies what
kind of `Scheduler` to use when a subscribe call happens.

[[faq.chain]]
== I Used an Operator on my `Flux` but it Doesn't Seem to Apply. What Gives?

Make sure that the variable you `.subscribe()` to has been affected by the
operators you think should have been applied to it.

Reactor operators are decorators. They return a different instance that wraps
the source sequence and add behavior. That is why the preferred way of using
operators is to *chain* the calls.

Compare the following two examples:

====
.without chaining (incorrect)
[source,java]
----
Flux<String> flux = Flux.just("foo", "chain");
flux.map(secret -> secret.replaceAll(".", "*")); <1>
flux.subscribe(next -> System.out.println("Received: " + next));
----
<1> The mistake is here. The result isn't attached to the `flux` variable.
====

====
.without chaining (correct)
[source,java]
----
Flux<String> flux = Flux.just("foo", "chain");
flux = flux.map(secret -> secret.replaceAll(".", "*"));
flux.subscribe(next -> System.out.println("Received: " + next));
----
====

This sample is even better (because it's simpler):

====
.with chaining (best)
[source,java]
----
Flux<String> secrets = Flux
  .just("foo", "chain")
  .map(secret -> secret.replaceAll(".", "*"))
  .subscribe(next -> System.out.println("Received: " + next));
----
====

The first version will output:

====
[source]
----
Received: foo
Received: chain
----
====

Whereas the two other versions will output the expected:

====
[source]
----
Received: ***
Received: *****
----
====

[[faq.monoThen]]
== My `Mono` `zipWith`/`zipWhen` Is Never Called

====
.example
[source,java]
----
myMethod.process("a") // this method returns Mono<Void>
        .zipWith(myMethod.process("b"), combinator) //this is never called
        .subscribe();
----
====

If the source `Mono` is either `empty` or a `Mono<Void>` (a `Mono<Void>` is
empty for all intents and purposes), some combinations will never be called.

This is the typical case for any transformer like the `zip` static method or
`zipWith`/`zipWhen` operators, which by definition need an element from each
source to produce their output.

Using data-suppressing operators on sources of `zip` is thus problematic.
Examples of data-suppressing operators include `then()`, `thenEmpty(Publisher<Void>)`,
`ignoreElements()` and `ignoreElement()`, `when(Publisher...)`.

Similarly, operators that use a `Function<T,?>` to tune their behavior, like `flatMap`,
do need at least one element to be emitted for the `Function` to have a chance
to apply. Applying these on an empty (or `<Void>`) sequence will never produce an element.

You can use `.defaultIfEmpty(T)` and `.switchIfEmpty(Publisher<T>)` to respectively
replace an *empty* sequence of `T` with a default value or a fallback `Publisher<T>`,
which could help avoid some of these situations. Note that this doesn't apply to
`Flux<Void>`/`Mono<Void>` sources, as you can only switch to another `Publisher<Void>`,
which is still guaranteed to be empty. Here's an example of `defaultIfEmpty`:

====
.use `defaultIfEmpty` before `zipWhen`
[source,java]
----
myMethod.emptySequenceForKey("a") // this method returns empty Mono<String>
        .defaultIfEmpty("") // this converts empty sequence to just the empty String
        .zipWhen(aString -> myMethod.process("b")) //this is called with the empty String
        .subscribe();
----
====

[[faq.retryWhen]]
== How to Use `retryWhen` to Emulate `retry(3)`?
The `retryWhen` operator can be quite complex. Hopefully this snippet of code
can help you understand how it works by attempting to emulate a simpler
`retry(3)`:
include::snippetRetryWhenRetry.adoc[]

[[faq.exponentialBackoff]]
== How to Use `retryWhen` for Exponential Backoff?
Exponential backoff produces retry attempts with a growing delay between each
of the attempts, so as not to overload the source systems and risk an all out
crash. The rationale is that if the source produces an error, it is already in
an unstable state and not likely to immediately recover from it. So blindly
retrying immediately is likely to produce yet another error and add to the
instability.

Since `3.2.0.RELEASE`, Reactor comes with such a retry baked in: `Flux.retryBackoff`.

For the curious, here is how to implement an exponential backoff with `retryWhen`
that delays retries and increase the delay between each attempt (pseudocode:
delay = attempt number * 100 milliseconds):

====
[source,java]
----
Flux<String> flux =
Flux.<String>error(new IllegalArgumentException())
    .retryWhen(companion -> companion
        .doOnNext(s -> System.out.println(s + " at " + LocalTime.now())) // <1>
        .zipWith(Flux.range(1, 4), (error, index) -> { // <2>
          if (index < 4) return index;
          else throw Exceptions.propagate(error);
        })
        .flatMap(index -> Mono.delay(Duration.ofMillis(index * 100))) // <3>
        .doOnNext(s -> System.out.println("retried at " + LocalTime.now())) // <4>
    );
----
<1> We log the time of errors.
<2> We use the `retryWhen` + `zipWith` trick to propagate the error after 3
retries.
<3> Through `flatMap`, we cause a delay that depends on the attempt's index.
<4> We also log the time at which the retry happens.
====

When subscribed to, this fails and terminates after printing out:
====
----
java.lang.IllegalArgumentException at 18:02:29.338
retried at 18:02:29.459 <1>
java.lang.IllegalArgumentException at 18:02:29.460
retried at 18:02:29.663 <2>
java.lang.IllegalArgumentException at 18:02:29.663
retried at 18:02:29.964 <3>
java.lang.IllegalArgumentException at 18:02:29.964
----
<1> first retry after about 100ms
<2> second retry after about 200ms
<3> third retry after about 300ms
====

== How Do I Ensure Thread Affinity Using `publishOn()`?

As described in <<schedulers, Schedulers>>, `publishOn()` can be used to switch
execution contexts. The `publishOn` operator influences the threading context
where the rest of the operators in the chain below it will execute, up to a new
occurrence of `publishOn`. So the placement of `publishOn` is significant.

For instance, in the example below, the `transform` function in `map()` is
executed on a worker of `scheduler1` and the `processNext` method in
`doOnNext()` is executed on a worker of `scheduler2`. Each **subscription** gets
its own worker, so all elements pushed to the corresponding subscriber are published
on the same `Thread`.

Single threaded schedulers may be used to ensure thread affinity for different stages in the
chain or for different subscribers.

====
[source,java]
----
EmitterProcessor<Integer> processor = EmitterProcessor.create();
processor.publishOn(scheduler1)
         .map(i -> transform(i))
         .publishOn(scheduler2)
         .doOnNext(i -> processNext(i))
         .subscribe();
----
====

== What Is a Good Pattern for Contextual Logging? (MDC)
As described in section <<context>>, `ThreadLocal` does not make much sense in Reactive Streams, where several streams could run steps on a common thread.
Instead of using `ThreadLocal`, Reactor offers the `Context`, a map-like object that is tied to a `Subscription` and not a `Thread`.

One recurring use of `ThreadLocal` in Java is for logging frameworks to store variables that are used in their logging pattern, generally by way of a `Map` called the MDC ("Mapped Diagnostic Context").

Unfortunately, this pattern is hard to opt out of and hard to apply transparently from a reactive library perspective.
This entry of the FAQ offers a possible intermediate solution when one wants to perform log statements in relation to events in the stream (`onNext`, `onError`, and `onComplete`).

The most straightforward way to perform such logging and get contextual information from the `Context` to the MDC is to wrap logging statements in a `doOnEach` operator with a little bit of boilerplate code.
This boilerplate depends on both the logging framework/abstraction of your choice and the information you want to put in the MDC, so it has to be in your codebase.

The following is an example of such a helper function around a single MDC variable and focused on logging `onNext` events, using Java 9 enhanced `Optional` API:

====
[source,java]
----
public static <T> Consumer<Signal<T>> logOnNext(Consumer<T> logStatement) {
	return signal -> {
		if (!signal.isOnNext()) return; <1>
		Optional<String> toPutInMdc = signal.getContext().getOrEmpty("CONTEXT_KEY"); <2>

		toPutInMdc.ifPresentOrElse(tpim -> {
			try (MDC.MDCCloseable cMdc = MDC.putCloseable("MDC_KEY", tpim)) { <3>
				logStatement.accept(signal.get()); <4>
			}
		},
		() -> logStatement.accept(signal.get())); <5>
	};
}
----
<1> `doOnEach` signals include onComplete and onError. In this example we're only interested in logging `onNext`
<2> We will extract one interesting value from the Reactor `Context` (see the <<context.api>> section)
<3> We use the `MDCCloseable` from SLF4J 2 in this example, allowing try-with-resource syntax for automatic cleanup of the MDC after the log statement is executed
<4> Proper log statement is provided by the caller as a `Consumer<T>` (consumer of the onNext value)
<5> In case the expected key wasn't set in the `Context` we use the alternative path where nothing is put in the MDC
====

Using this boilerplate code ensures that we are good citizen with the MDC: we set a key right before we execute a logging statement and remove it immediately after.
There is no risk of polluting the MDC for subsequent logging statements.

Of course, this is a suggestion. You might be interested in extracting multiple values from the `Context`, or in also logging things in case of `onError`.
You might want to create additional helper methods for these cases, or craft a single method that makes use of additional lambdas to cover more ground.

In any case, the usage of the above helper method could look like the following reactive web controller:

====
[source,java]
----
@GetMapping("/byPrice")
public Flux<Restaurant> byPrice(@RequestParam Double maxPrice, @RequestHeader(required = false, name = "X-UserId") String userId) {
	String apiId = userId == null ? "" : userId; <1>

	return restaurantService.byPrice(maxPrice))
			   .doOnEach(logOnNext(r -> LOG.debug("found restaurant {} for ${}", <2>
					r.getName(), r.getPricePerPerson())))
			   .subscriberContext(Context.of("CONTEXT_KEY", apiId)); <3>
}
----
<1> We will need to get the contextual information from the request header to put it in the `Context`
<2> Here we apply our helper method to the `Flux` using `doOnEach`. Remember operators see `Context` values defined below them.
<3> We write the value from the header to the `Context` using the chosen key `CONTEXT_KEY`.
====

In this configuration, the `restaurantService` can emit its data on a shared thread yet the logs will still reference the correct `X-UserId` for each request.

For completeness, let's also see what an error-logging helper could look like:

====
[source,java]
----
public static Consumer<Signal<?>> logOnError(Consumer<Throwable> errorLogStatement) {
	return signal -> {
		if (!signal.isOnError()) return;
		Optional<String> toPutInMdc = signal.getContext().getOrEmpty("CONTEXT_KEY");

		toPutInMdc.ifPresentOrElse(tpim -> {
			try (MDC.MDCCloseable cMdc = MDC.putCloseable("MDC_KEY", tpim)) {
				errorLogStatement.accept(signal.getThrowable());
			}
		},
		() -> errorLogStatement.accept(signal.getThrowable()));
	};
}
----
====

Nothing much has changed, except for the fact that we check that the `Signal` is effectively an `onError`, and that we provide said error (a `Throwable`) to the log statement lambda.

Applying this helper in the controller is very similar to what we've done before:

====
[source,java]
----
@GetMapping("/byPrice")
public Flux<Restaurant> byPrice(@RequestParam Double maxPrice, @RequestHeader(required = false, name = "X-UserId") String userId) {
	String apiId = userId == null ? "" : userId;

	return restaurantService.byPrice(maxPrice))
			   .doOnEach(logOnNext(v -> LOG.info("found restaurant {}", v))
			   .doOnEach(logOnError(e -> LOG.error("error when searching restaurants", e)) <1>
			   .subscriberContext(Context.of("CONTEXT_KEY", apiId));
}
----
<1> In case the `restaurantService` emits an error, it will be logged with MDC context here
====

//TODO reactive gems
